## R分析法

> LR分析是自底向上语法分析的方法，通过最左归约（寻找句柄）来判断一个程序语句是不是该文法的语句。LR分析法又分为了LR\(0\)、SLR\(1\)、LR\(1\)、LALR\(1\)分析。通过循序渐渐来规范和完善这个分析方法。

## LR分析法概述

* 是一种自下而上的语法分析技术
  * L从左到右描述输入符号
  * R构建一个最右推导的逆过程——最左归约
  * k超前读入k个符号，以便确定归约用的产生式
* LR分析器
  * 移进归约分析器 + LR分析表
* 特殊性
  * 栈 = 状态栈 + 文法符号栈
  * 分析表 = 动作表action + 状态转移表goto
* 各种LR分析表
  * 采用不同的构造方法
    * LR\(0\)表构造法——基础
    * 简单LR\(SLR\(1\)\)表构造法——理论过度
    * 规范LR\(1\)表构造法——理论过渡
    * 向前LR\(LALR\(1\)\)表构造法——实用
  * 不同点
    * 构造分析表的方法不同
    * 分析能力不同，实现效率不同
  * 共同点
    * 逻辑结构
    * 工作原理（状态转移）

## LR分析器

* LR分析器模型
  * 输入缓冲区存放输入的字符串，通过LR分析程序对于状态栈和符号栈、动作表和转移表（LR分析表）对应产生式序列。来完成LR分析。

![](/assets/0101.PNG)

* 分析表举例

  * si将符号a,状态i压人栈
  * ri用第i个产生式归约

  （img：分析表的图片）

* 分析过程举例

  * 对于符号串，一步步归约

  （img：归约过程举例）

* LR分析算法

  * 四个部分

  ![](/assets/0102.PNG)

* LR文法的定义

  * LR文法
    * 能够构造一张不含多重入口的LR分析表的文法，即LR分析表的每个入口均是惟一确定的
  * LR\(k\)文法
    * 能用一个每步顶多向前检查k个输入符号的LR分析器进行分析的文法
    * 对于大多数的程序设计语言来说，k=0或1就足够了
  * 非LR文法
    * 栈顶内容和输入符号已知时仍无法唯一确定应采取的动作

## LR\(0\)分析

* LR\(0\)分析举例
  * LR分析表
    * action\[k,a\] 状态k面临输入符号a时的动作
      * 移进sj action\[k,a\]=sj，将状态j移进状态栈，a移进符号栈，输入指针移向下一位置
      * 归约rj action\[k,a\]=rj，用第j个产生式A-&gt;β进行归约，\|β\|=m，移去状态栈的m状态和符号栈的m个符号，用当前状态栈顶状态k'和A查got\(k',A\)=t，将状态t移进状态栈，A移进符号栈。输入指针不动。
      * 接受acc宣布输入符号串为一个句子
      * 报错error状态与文法符号不匹配，宣布输入符号串不是句子
    * goto\[k,X\]状态k遇到文法符号X时转移到下一状态
* 规范句型的活前缀
  * 可归前缀和活前缀的定义
    * 前缀：一个矩形的任意首部
    * 可归前缀：LR分析过程中每次采取归约动作前符号栈中的内容，即规范句型的可归前缀
    * 活前缀：形成可归前缀之前包括可归前缀在内的所有规范句型的前缀
  * 分析决策依据栈顶状态和当前输入符号是什么
    * 利用LR\(0\)项目构建识别活前缀和句柄的DFA
* LR\(0\)项目

  * 定义、意义和构造方法

    * 在文法G的产生式右部某个位置标有. 的产生式，称为文法的一个LR\(0\)项目\(Item\)
    * 例如$$A -> .XYZ$$ 
    * 约定$$A->ε 对应的LR(0)项目为A->.$$ 
    * 每个项目的含义与 . 的位置有关

    * {已识别过的部分}.{待识别的部分}

  * 分成四种 `归约 移进 接受 待约`
    * $$$$$$A -> α. 归约项目(Reduce)$$
      * 句柄形成于栈顶，可归约
    * $$S' -> a. 接受项目$$
      * 接受，句子分析成功
    * $$A -> α.aβ 移进项目(Shift)$$
      * 移进符号a
    * $$A -> α.Bβ 待约项目$$
      * 等待分析完B，才能继续分析A的右部

* 识别活前缀的DFA
  * 构造方法
    * 先按一定规则用所有LR\(0\)项目表示状态构造NFA
    * 再对NFA确定化和最小化最后得到一个识别活前缀的DFA
    * I0,I1......I11状态LR\(0\)项目集合，状态（项目集）间转移函数——GO函数
* LR\(0\)项目集规范族
  * 定义和构造方法
    * 文法的LR\(0\)项目集规范族，记作C
      * 构成识别一个文法活前缀的DFA的项目集合（或状态）的全体
      * 例如 C={I0,I1,...,I11}
    * LR\(0\)项目集（合）
      * 识别一个文法活前缀的DFA的状态
    * 函数go
      * LR\(0\)项目集间的转移函数
  * 构造
    * 拓广文法G‘
      * 引进新的开始符号S'及新产生式$$S' = S$$
      * $$S' = .S$$ 对应分析开始
      * $$S' = S.$$对应分析成功结束
    * LR\(0\)项目集规范族的构造算法
      * 计算项目集闭包CLOSURE\(I\)
        * 设I是文法G’的任一项目集，计算I的闭包CLOSURE\(I\)的方法是
          * $$I ∈ CLOSURE(I)$$
          * 若$$A -> a·Bβ ∈ CLOSURE(I)$$则对任何关于B的产生式$$B->·γ ∈ CLOSURE(I)$$
          * 重复执行上述步骤，直至CLOSURE\(I\)不再增大
      * 计算状态转移函数GO
        * 确定在某状态遇到一个文法符号后的状态转移目标
        * 当前项目集I，文法符号X -&gt; 下一项目集
        * $$GO(I,X) = CLOSURE(J) 其中 J = { A -> aX·β | A ->a·Xβ∈I }$$
        * ![](/assets/0103.PNG)
* LR\(0\)分析表
  * 构造方法
    * 设G'的LR\(0\)项目集规范族C={I0,I1,..,In}，令每个项目集Ik的下表作为分析器的状态，共有n+1个状态
    * ACTION表的构造方法
      * $$若A→α·aβ∈Ik 且GO(Ik,a)=Ij,则ACTION[k,a]=sj$$
      * $$若A→α· ∈Ik,则a∈VT∪{#}，ACTION[k,a]=rj    （假定产生式 A→α是文法 G’的第j个产生式）$$
      * $$(3)若S’→S·∈Ik ,则ACTION[k,#]=acc$$
    * GOTO表的构造方法
      * $$若 GO(Ik,A)=Ij,则GOTO[k,A]=j$$
    * 错误标志
      * 分析表中凡是不能以上规则填入信息的空白格均置上“错误标志”
  * 项目集I的相容与不相容
    * 归约-归约冲突\(Reduce/Reduce Conflict\)
    * 移进-归约冲突\(Shift/Reduce Conflict\)
    * I是相容的：如果I中既没有归约—归约冲突，又没有移进—归约冲突
    * I是不相容的：如果I中有归约—归约冲突，或移进—归约冲突
* LR\(0\)文法及LR\(0\)分析存在问题
  * LR\(0\)文法
    * 定义一：能够构造一张不含多重入口的LR\(0\)分析表的文法
    * 定义二：对于拓广文法G'，如果∀I∈C，都是相容的，状态（项目集
      * 既含移进项目，又含归约项目
      * 含有多个归约项目
  * LR\(0\)分析表含有多重入口，LR\(0\)分析无效，并不是总是有效的

## SLR\(1\)分析

* LR\(0\)分析存在问题及解决方法

  * 当LR\(0\)含有互相冲突的项目时，则需要向前展
      望符号串，检查下一个输入符号的状态
  * 例 项目集 I={ X→α· bβ，A→α·，B→α· }
      当面临输入符号b时，应该选择移进b,还是归约
      到A,或归约到B？
  * 解决办法 当状态I,面临输入符号是a时

    * \(1\) 若a=b,则移进b

    * \(2\) 若a∈FOLLOW\(A\),则用产生式A→α进行归约

    * \(3\) 若a∈FOLLOW\(B\),则用产生式B→α进行归约

    * \(4\) 此外,报错

* SLR\(1\)冲突解决方法

  * 假定LR\(0\)规范族的一个项目集I
    * 中
      含有m个移进项目
       A1→α·a1β1,A2→α·a2β2,…,Am→α·amβm
    * 同时含有n个归约项目
       B1→α· ,B2 →α· ,…, Bn →α·
  * 如果下列集合两两不相交  
    {a1,a2,…,am},FOLLOW\(B1\),FOLLOW\(B2\),…,FOLLOW\(Bn\)

  * 当状态I面临输入符号a时，按以下规则移进归约  
    若a=ai，i=1,2,…,m, 则移进

  * 若a∈FOLLOW\(Bi\),i=1,2,…,n,则用Bi→α归约  
    此外,报错

* SLR\(1\)分析表的构造算法
  * ![](/assets/0104.PNG)
* SLR\(1\)文法
  * SLR\(1\)分析表
    * 对于文法G,按照SLR\(1\)冲突解决办法,构造出来的每个入口不含多重定义的LR分析表
  * SLR\(1\)文法
    * 具有SLR\(1\)分析表的文法
  * SLR分析器
    * 使用SLR\(1\)分析表的分析器
* SLR\(1\)分析的局限性

  * LR\(0\)与SLR\(1\)的分析表的构造算法不同
    * LR\(0\) 分析对所有终结符均采用归约动作
    * SLR\(1\) 分析参考 FOLLOW 集确定归约动作
  * SLR\(1\)文法的分析能力强于LR\(0\)方法

    * LR\(0\) 分析表出现冲突

    * SLR\(1\) 分析表无冲突

  * 局限性

    * 如果SLR\(1\)分析表仍有多重入口，说明  SLR\(1\)冲突解决办法无法解决移进-归约冲突或归约-归约冲突,则该文法不是SLR\(1\)文法

    * 说明仅使用LR\(0\)项目集和FOLLOW集还不足以分析这类文法

## LR\(1\)分析

## LALR\(1\)分析

## LR分析法小结



